//====== Copyright © 1996-2005, Valve Corporation, All rights reserved. =======
//
// Purpose: Aperture entity declarations
//
//=============================================================================

@include "base.fgd"
@include "portal.fgd"
@include "halflife2.fgd"

@SolidClass base(Targetname, worldbase, ResponseContext) = worldspawn : 
	"This is the world entity. Each map can only contain one, and it's automatically created for you."
[
	paintinmap(choices) : "Paint in map" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	
	maxblobcount(integer) : "Max number of blobs" : 250 : "Max number of blobs should NOT be exceed 250"
]

@PointClass base(Targetname, Parentname, Angles) studio("models/editor/angle_helper.mdl") = point_futbol_shooter : 
	"Fires prop_futbols at a target entity"
[
		input SetTarget(string) : "Set new launch target"
		input ShootFutbol(void) : "Shoot a futbol at the target"
		
		output OnShootSuccess(void) : "Called when a futbol is successfully fired."
		output OnShootFail(void) : "Called when a futbol fails to fire."
		
		launchSpeed(float) : "Launch speed" : "100" : "Speed to launch the futbol."
]


@BaseClass = LinkedPortalDoor : "An entity that can be linked to another door and create a passage between them dynamically."
[
	partnername(target_destination) : "Linked Partner" : : "Another 'prop_linked_portal_door' entity which will link to this one."

	input SetPartner(string) : "Set a new partner door."
	input Open(void) : "Open the door and cause the portal to activate."
	input Close(void) : "Close the door and cause the portal to deactivate."

	output OnOpen(void) : "Called when the door has started its open animation."
	output OnClose(void) : "Called when the door has started its close animation."
	output OnEntityTeleportFromMe(void)		: "When any entity is teleported from this portal to the linked partner."
	output OnPlayerTeleportFromMe(void)		: "When the player is teleported from this portal to the linked partner."
	output OnEntityTeleportToMe(void)		: "When any entity is teleported from this linked partner to the portal."
	output OnPlayerTeleportToMe(void)		: "When the player is teleported from this linked partner to the portal."
]

@BaseClass = BaseProjector : "The base for all the different projectors (wall & tractor beam)."
[
	StartEnabled(boolean) : "Start Enabled" : 1 : "If the projector should start enabled."
	
	DisableHelper(boolean) : "Disable Placement Helper" : 0 : "Disable the automatically created placement helper to prevent it from fighting with a custom one."
	
	input Enable(void) : "Enables projection from this projector."
	input Disable(void) : "Disables projection from this projector."
]

@PointClass base(Targetname) sphere(radius) = info_target_personality_sphere : "Personality Sphere Info Target"
[
	sphereLine(string) : "Sphere Line" : "" : "Line sphere will speak when we are looking at this target."
	radius(float) : "Radius" : 16 : "Radius of this object"
]

@PointClass base(Targetname, Parentname, Angles) iconsprite("editor/info_target.vmt") studioprop() = info_target : 
	"Portal2 override of info_target. An entity that does nothing. Very useful as a positioning entity for other entities to refer to (i.e. the endpoint of an env_beam)"
[
	spawnflags( Flags ) =
	[
		1 : "Transmit to client (respect PVS)" : 0
		2 : "Always transmit to client (ignore PVS)" : 0
	]
	model(studio) : "World Model"
]

@PointClass base(Targetname, Parentname, Angles) studioprop("models/props/tripwire_turret.mdl") = prop_rocket_tripwire : 
	"A stationary tripwire that fires a rocket when crossed."
[
	RocketSpeed(float) : "Rocket Speed" : 450 : "Speed the rocket will travel at."
	RocketLifetime(float) : "Rocket Lifetime" : 20 : "The rocket will automatically detonate after this number of seconds."
	input ForceFire(void) : "Forces the rocket turret to fire."
	
	StartDisabled(choices) : "Initial State" : 0 =
	[
		0 : "Enabled"
		1 : "Disabled"
	]

	output OnTripped(void) 	: 	"Fires when the laser has been tripped"
	output OnRocketExplode(void) 	: 	"Fires when the rocket explodes"
	
	input EnableTripwire(void) : "Enables the rocket tripwire."
	input DisableTripwire(void) : "Disables the rocket tripwire."
]

@PointClass base(BasePropPhysics, RenderFields) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_physics :
	"A prop that physically simulates as a single rigid body. It can be constrained to other physics objects using hinges "+
	"or other constraints. It can also be configured to break when it takes enough damage. "+
	"Note that the health of the object will be overridden by the health inside the model, to ensure consistent health game-wide. "+
	"If the model used by the prop is configured to be used as a prop_dynamic (i.e. it should not be physically simulated) then it CANNOT be "+
	"used as a prop_physics. Upon level load it will display a warning in the console and remove itself. Use a prop_dynamic instead."
[
	allowfunnel(boolean) : "Allow Portal Funneling" : 1 : "Whether or not this object should auto-funnel into a portal."
]

@PointClass base(BasePropPhysics) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_physics_override :
	"A prop that physically simulates as a single rigid body. It can be constrained to other physics objects using hinges "+
	"or other constraints. It can also be configured to break when it takes enough damage. Health can be overridden on this version."
[
	health(integer) : "Health" : 0 : "Number of points of damage to take before breaking.  0 means don't break."
	
	// Inputs
	input Ignite(void) : "Ignite, burst into flames."
	input IgniteLifetime(float) : "Ignite, with a parameter lifetime."
	input IgniteNumHitboxFires(integer) : "Ignite, with a parameternumber of hitbox fires."
	input IgniteHitboxFireScale(float) : "Ignite, with a parameter hitbox fire scale."
]

@SolidClass base(Targetname) = func_camera_target :
	"Used to produce perfectly reflective glass that renders world + entities."
[
]

@PointClass base(Targetname, Parentname, Angles, LinkedPortalDoor) studio("models/editor/axis_helper_thick.mdl") line(255 255 0, targetname, partnername) = linked_portal_door :
"A door which is linked by a portal to another 'linked_portal_door' entity."
[
	width(integer) : "Width" : 128 : "Width of the desired portal."
	height(integer) : "Height" : 128 : "Height of the desired portal."
	startactive(boolean) : "Start Active" : 0 : "Whether to start the linkage as active from the start."
]

@PointClass base(Targetname, Parentname, Angles, LinkedPortalDoor) studio("models/props/portal_door.mdl") line(255 255 0, targetname, partnername) = prop_linked_portal_door :
"A door which is linked by a portal to another 'prop_linked_portal_door' entity."
[
	lightingorigin(target_destination) : "Lighting Origin" : "" : "Select an info_lighting to specify a location to sample lighting from for all gibs spawned by this shooter, instead of their own origins."

	output OnFullyOpen(void) : "Called when the door has finished its open animation."
	output OnFullyClosed(void) : "Called when the door has finished its close animation."
]

@PointClass base(Targetname, Parentname, Angles ) studio("models/props/switch001.mdl") = prop_button :
"A button which is activated by player use or by game inputs."
[
	Delay(float) : "Delay Before Reset" : 1 : "Amount of time, in seconds, after the button has been pressed before it returns to the starting position. Once it has returned, it can be used again."
	istimer(boolean) : "Play timer sound?" : 0 : "If set, this button will play timer sounds while button is depressed. This allows fast reset by default - use Prevent fast reset to stop this."
	preventfastreset(boolean) : "Prevent fast reset?" : 0 : "Buttons that are timer's allow you to reset early - use this to make the button stick for the entire duration."
	
	skin(choices) : "Skin" : 0 =
	[
		0 : "Clean"
		1 : "Rusted"
	]

	input Press(void) : "Cause the button to be pressed."
	input Lock(void) : "Locks the button."
	input UnLock(void) : "UnLocks the button."
	input CancelPress(void) : "Causes the button to reset quietly and without firing OnButtonReset outputs."
	
	output OnPressed(void) : "Called when the button has been pressed."
	output OnPressedBlue(void) : "Called in Coop when the button has been pressed by the Blue player."
	output OnPressedOrange(void) : "Called in Coop when the button has been pressed by the Orange player."
	output OnButtonReset(void) : "Called when the button has reset after being pressed."
]

@PointClass base(prop_button) studio("models/props_underground/underground_testchamber_button.mdl") = prop_under_button :
"A button which is activated by player use or by game inputs, for use in underground test chambers"
[
]

@PointClass base(Targetname, Parentname, Angles ) studio() = prop_floor_button :
"A floor button which is activated by a player or objects."
[
	model(studio) : "Button model" : "models/props/portal_button.mdl" : "Button model must have the correct sequences and attachments in order to work as a button."
	input PressIn(void) : "Activate the button as if it was pressed, sending it to the bottom position."
	input PressOut(void) : "Unpress the button, sending it to the top position."
	output OnPressed(void) : "Called when the button has been pressed."
	output OnPressedBlue(void) : "Called in Coop when the button has been pressed by the Blue player."
	output OnPressedOrange(void) : "Called in Coop when the button has been pressed by the Orange player."
	output OnUnPressed(void) : "Called when the button has been unpressed."
]

@PointClass base(Targetname, Parentname, Angles ) studio("models/props/box_socket.mdl") = prop_floor_cube_button :
"A floor button which is activated by a prop_weighted_cube."
[
	AcceptsBall(boolean) : "Accepts Balls" : 1 : "If this button gets activated by the spherical cubes?"

	input PressIn(void) : "Activate the button as if it was pressed, sending it to the bottom position."
	input PressOut(void) : "Unpress the button, sending it to the top position."
	output OnPressed(void) : "Called when the button has been pressed."
	output OnUnPressed(void) : "Called when the button has been unpressed."
]

@PointClass base(Targetname, Parentname, Angles ) studio("models/props/ball_button.mdl") = prop_floor_ball_button :
"A floor button which is only activated by a prop_weighted_cube that is set to Cube Type = Sphere."
[
	input PressIn(void) : "Activate the button as if it was pressed, sending it to the bottom position."
	input PressOut(void) : "Unpress the button, sending it to the top position."
	output OnPressed(void) : "Called when the button has been pressed."
	output OnUnPressed(void) : "Called when the button has been unpressed."
]

@PointClass base(Targetname, Parentname, Angles ) studio("models/props_underground/underground_floor_button.mdl") = prop_under_floor_button :
"A floor button which is activated by a player or objects, for use in the underground test chambers"
[
	output OnPressed(void) : "Called when the button has been pressed."
	output OnUnPressed(void) : "Called when the button has been unpressed."
]

@PointClass base(Targetname, Angles, BaseProjector) studio("models/props/wall_emitter.mdl") = prop_wall_projector : "Wall Projector"
[
]

@PointClass base(Targetname, Parentname, Angles, EnableDisable) sphere(radius) studio("models/editor/angle_helper.mdl") = info_placement_helper : "Placement helper"
[
	radius(float) : "Radius" : 16 : "Radius in which to influence placement.,"
	proxy_name(target_destination) : "Proxy Entity Name" : : "Name of the entity we want to use for our real placement position."
	attach_target_name(string) : "Attach Entity Name" : : "Name of the entity we want force our attachment to. Used to combine objects."

	snap_to_helper_angles(boolean) : "Use helper's angles" : 0 : "Placed objects will snap to the angles of the placement helper."

	force_placement(boolean) : "Force Placement" : 0 : "Avoids placement rules when placing at this helper."

	output OnObjectPlaced(void) : "An object has been successfully placed using us as a guide."
	output OnObjectPlacedSize(integer) : "When an object is successfully placed, this sends the scale level as an out value"
]

@PointClass base(Targetname) iconsprite("editor/info_target.vmt") studioprop() = info_player_ping_detector : "Player Ping Detector"
[
	FuncTankName(target_destination) : "Func Tank Entity" : : "Name of the func_tank that will be told to look at the ping location when detected."
	TeamToLookAt(choices) : "Team to Observe" : 2 : "Which team's pings to look at." =
	[
		1 : "Both"
		2 : "Orange"
		3 : "Blue"
	]
	Enabled(choices) : "Default State" : 1 : "Is this entity enabled by defualt or not?" =
	[
		0 : "Disabled"
		1 : "Enabled"
	]
	
	input Enable(void) : "Starts listening for pings and will fire outputs when found."
	input Disable(void): "Disable this entity from listening for pings."
	input Toggle(void): "DToggle from Enabled to Disabled and vice versa."
	
	output OnPingDetected(void) : "Fired when a ping is detected."
]

@SolidClass base(Trigger) = func_placement_clip : "Specifies a region where things cannot be built."
[
]

//-------------------------------------------------------------------------
//
// NPCs
//
//-------------------------------------------------------------------------

@FilterClass base(BaseFilter) iconsprite("editor/filter_name.vmt") = filter_player_held :
	"A filter that only accepts objects held by the player."
[
]

@PointClass base(Parentname, Targetname, Angles, Reflection) studio() = env_portal_laser
: "Laser beam that will move through portals and reflect off metal surfaces."
[
	NoPlacementHelper(boolean) : "No placement helper" : 0 : "Don't automatically create a portal placement helper at the end of the laser."
	model(studio) : "Laser model" : "models/props/laser_emitter.mdl"
	
	StartState(choices) : "Start off?" : 0 =
	[
		1 : "Yes"
		0 : "No"
	]
	
	LethalDamage(choices) : "Deal lethal damage" : 0 =
	[
		0 : "Non-lethal"
		1 : "Lethal"
	]
	
	AutoAimEnabled(boolean) : "Should auto aim" : 1 : "Default to enabled"

	skin(choices) : "Skin Type" : 0 =
	[
		0 : "Clean"
		1 : "Rusted"
	]

	input Toggle( void ) : "Toggle the laser on and off."
	input TurnOn( void ) : "Turn the laser on."
	input TurnOff( void ) : "Turn the laser off."
]


@PointClass base(Targetname) = point_laser_target
: "Target for lasers to strike. The entity will fire outputs when struck and unstruck."
[
	terminalpoint(boolean) : "Terminal Point" : 1

	output OnPowered(void) : "Fired when a laser hits the target."
	output OnUnpowered(void) : "Fired when a laser has stopped hitting the target."
]

@PointClass base(Parentname, Targetname, Reflection) studio() = prop_laser_catcher
: "Laser catcher that has target for lasers to strike. The entity will fire outputs when struck and unstruck."
[
	SkinType(choices) : "Skin Type" : 0 =
	[
		0 : "Clean"
		1 : "Rusted"
	]
	
	model(studio) : "laser catcher model" : "models/props/laser_catcher.mdl"
	output OnPowered(void) : "Fired when a laser hits the target."
	output OnUnpowered(void) : "Fired when a laser has stopped hitting the target."
]

@PointClass base(Parentname, Targetname, Reflection) studio() = prop_laser_relay
: "Laser catcher that has target for lasers to strike. The entity will fire outputs when struck and unstruck."
[
	model(studio) : "laser relay model" : "models/props/laser_receptacle.mdl"
	output OnPowered(void) : "Fired when a laser hits the target."
	output OnUnpowered(void) : "Fired when a laser has stopped hitting the target."
]

@PointClass base(Targetname,Angles, Reflection) studio( "models/props/metal_box.mdl" ) = prop_weighted_cube : "Weighted Cube"
[
	skin(choices) : "Skin (OLD)" : 0 =
	[
		0 : "Standard"
		1 : "Companion"
		2 : "Standard Activated"
		3 : "Reflective"
		4 : "Sphere"
		5 : "Antique"
	]

	CubeType(choices) : "Cube Type" : 0 =
	[
		0 : "Standard"
		1 : "Companion"
		2 : "Reflective"
		3 : "Sphere"
		4 : "Antique"
	]

	SkinType(choices) : "Skin Type" : 0 =
	[
		0 : "Clean"
		1 : "Rusted"
	]

	PaintPower(choices) : "Paint Power" : 4 :
	"The paint power of the cube." =
	[
		0 : "Bounce"
		1 : "Stick"
		2 : "Speed"
		3 : "Portal"
		4 : "None"
	]

	NewSkins(boolean) : "Use new skins" : 0 : "Use the values in the Cube Type and Skin Type fields instead of the Skin(OLD) field."

	allowfunnel(boolean) : "Allow Portal Funneling" : 1 : "Whether or not this object should auto-funnel into a portal."

	input  EnablePortalFunnel(void) : "Enable portal funneling behavior."
	input  DisablePortalFunnel(void) : "Disable portal funneling behavior."

	input  Dissolve(void) : "Dissolves the cube."
	input  SilentDissolve(void) : "Kills the cube and fires its OnFizzled output."
	input  PreDissolveJoke(void) : "GLaDOS make a funny about the cube."
	input  ExitDisabledState(void) : "Exits the disabled state of a reflective cube."
	output OnFizzled(void) : "Fired when a cube is fizzled."
	output OnOrangePickUp(void) : "Orange picked up the cube."
	output OnBluePickUp(void) : "Blue picked up the cube."
	output OnPlayerPickup(void) : "Player picked up the cube."
	output OnPhysGunDrop(void) : "Player dropped the cube."
	output OnPainted(void) : "Cube got painted."
]

@SolidClass base(Trigger) = trigger_catapult : "Catapult the player in a given diretion at a given velocity."
[
	playerSpeed(float) : "Player Speed" : 450 : "Speed at which to launch the players (u/sec)"
	physicsSpeed(float) : "Physics Object Speed" : 450 : "Speed at which to launch physics objects (u/sec)"
	useThresholdCheck(boolean) : "Use Threshold Check" : 0
	entryAngleTolerance(float) : "Entry Angle Tolerance" : "0.0" : "Flung object's velocity must be pointing this much at the target. Specify a value between [-1...1] 1 means exactly, 0 means within 180 degrees -1 means any angle is accepted. This is only used if Use Threshold Check is set to yes."
	useExactVelocity(boolean) : "Use Exact Velocity" : 0 : "Try to fling exactly at the speed specified - this prevents the added upward velocity from a launch target."
	exactVelocityChoiceType(choices) : "Exact Solution Method" : 0 :
	"Using exact velocity generates two correct solutions. Use this to force which one you choose." =
	[
		0 : "Best"
		1 : "Solution One"
		2 : "Solution Two"
	]
	lowerThreshold(float) : "Lower Threshold" : "0.15" : "Flung object must be within this percentage value in order to activate fling. Specify a value between [0...1] (default is .15) This is only used if Use Threshold Check is set to yes."
	upperThreshold(float) : "Upper Threshold" : "0.30" : "Flung object must be within this percentage value in order to activate fling. Specify a value between [0...1] (default is .30) This is only used if Use Threshold Check is set to yes."
	launchDirection(angle) : "Launch direction" : "0 0 0" : "Direction to launch the player in."
	launchTarget(target_destination) : "Launch target" : "" : "Entity to try to 'hit' when we're launched."
	onlyVelocityCheck(boolean) : "Only check velocity" : 0 : "Only check velocity of the touching object - don't actually catapult it.  Use in conjunction with OnCatapulted to create velocity checking triggers.  Only works when Use Threshhold Check is enabled."
	applyAngularImpulse(boolean) : "Apply angular impulse" : 1 : "If a random angular impulse should be applied to physics objects being catapulted."
	AirCtrlSupressionTime(float) : "Air Control SupressionTime" : "-1.0" : "[Launch by target only!]If greater than zero, supress player aircontrol for this number (in seconds). If less than zero use the default (quarter second)."

	output OnCatapulted(void) : "The object has been launched."
]

@PointClass base(BasePropPhysics) studio( "models/props/futbol.mdl" ) = prop_glass_futbol : "Magic glass futbol which the player uses to power futbol sockets."
[
	SpawnerName(string)		: "Spawner Name" : "" : "Name of prop_glass_futbol_spawner for this futbol to respawn in once broken."
]

@PointClass base(Targetname) studio( "models/props/futbol_dispenser.mdl" ) = prop_glass_futbol_spawner : "Spawns magic glass futbols. Will re-create a futbol when it's created futbol breaks."
[
	StartWithFutbol(boolean) : "Start with Futbol" : "1" : "Set true if this spawner starts with a futbol in it. Set to false if this spawner's futbol will be maunally placed in the map."

	// Inputs
	input ForceSpawn(void)	: "Spawns a new futbol. Usually isn't nessicary, because futbols respawn automatically if broken."
	
	// Outputs
	output OnFutbolSpawned(void) : "Created a new futbol."
	output OnFutbolGrabbed(void) : "Player has taken the futbol out of this spawner."
]

@PointClass base(Targetname) studio( "models/props/futbol_socket.mdl" ) = prop_glass_futbol_socket : "Catches futbols and fires an output."
[
	// Outputs
	output OnFutbolReleased(void) : "Player has taken the futbol out of this socket."
	output OnFutbolCaught(void)	: "This socket has captured a futbol."
]

@PointClass base(Targetname) = portalmp_gamerules : "Proxy entity for Portal 2 Gamerules"
[	
	input AddRedTeamScore(integer) : "Add to the Red team score (can be a negative number)"
	input AddBlueTeamScore(integer) : "Add to the Blue team score (can be a negative number)"
]

@PointClass base(Parentname, Targetname, Angles) studio("models/effects/cappoint_hologram.mdl") = item_nugget : "Aperture Incentivizing Nugget"
[
	GroupName(string) : "Group Name" : : "Giving nuggets a group name hints the game that they are intended to be a group"
	RespawnTime(float) : "Respawn Time" : 30 : "Number of seconds between when a nugget is collected and when it respawns"
	PointValue(choices) : "Point Value" : 1 =
	[
		1 : "1"
		5 : "5"
		10 : "10"
		25 : "25"
	]
]

@SolidClass base(func_portal_detector) = func_portalled : "Fires outputs when an entity teleports through a portal in its volume"
[
	FireOnDeparture(boolean) : "Fire On Departure" : 1 : "Fire when the entity is entering this portal"
	FireOnArrival(boolean) : "Fire On Arrival" : 1 : "Fire when the entity is exiting this portal"		
	FireOnPlayer(boolean) : "Player" : 1 : "Fire when a player has portalled"
	
	output OnEntityPrePortalled(void)	: "Fires when the entity is about to portal."
	output OnEntityPostPortalled(void)	: "Fires when the entity is done portalling."
]

@PointClass base(Targetname) = logic_player_slowtime : "Start/stops player being in slow time"
[
	input StartSlowingTime(float) : "Start slowing time for the player (with a set duration)."
	input StopSlowingTime(void) : "Stop slowing time for the player."
]

@PointClass base(Targetname) = logic_timescale : "Changes the server's timescale"
[
	BlendTime(float) : "Blend Time" : 0 : "The amount of time it takes to ramp to the desired timescale when triggered."
	input SetDesiredTimescale(float) : "Sets the desired timescale and starts slowing time (will blend to desired using the specified blend time)."
	input SetTimescaleBlendTime(float) : "Set the amount of time that it takes to ramp to the desired timescale when triggered."
]

@PointClass base(Targetname) = env_player_viewfinder : "When enabled, the viewfinder screen overlay will turn on."
[
	input ShowViewFinder(void) : "Shows the view finder scren overlay."
	input HideViewFinder(void) : "Hides the view finder scren overlay."
]

@PointClass base(Targetname, PlayerClass, Angles) studio("models/editor/playerstart.mdl") = info_coop_spawn : "Player spawns for cooperative mode"
[
	Enabled(choices) : "Initial State" : 0 =
	[
		0 : "Disabled"
		1 : "Enabled"
	]
	
	StartingTeam(choices) : "Team" : 0 =
	[
		0 : "Any"
		2 : "Red"
		3 : "Blue"
	]
	
	ForceGunOnSpawn(boolean) : "Force gun on spawn" : 0 : "Force the blue player to start with the portal gun and the red player to start with the paint gun."
	
	input Enable(void) : "Enable the spawn point to be used."
	input SetAsActiveSpawn(void) : "Enable the spawn point to be used, disabling all other spawn points that do not share the same name."
	input Disable(void) : "Disable the spawn point from being used."
	input SetTeam(integer) : "Set the team this spawn point is for. 0 and 1 are any team. 2 is red, 3 is blue"
]

@PointClass base(TalkNPC,Parentname) studio("models/npcs/personality_sphere/personality_sphere.mdl") = npc_personality_core
[
	ModelSkin(choices) : "Alt Model Skin" : 0 : "If using the 'alt' skin, this sets the eye color -- If not using the alt skin, (0 = broken) (1=normal)" =
	[
		0 : "Blue Eye / Broken"
		1 : "Green Eye / Normal"
		2 : "Red Eye / NA"
		3 : "Purple Eye / NA"
	]

	altmodel(choices) : "Use Alternate Skins" : 0 : "Use the model with corrupted skins, instead of the skins in the original model. " =
	[
		0 : "No"
		1 : "Yes"
	]
	
	output OnPlayerPickup(void) : "Fired whenever the player picks up the core."
	output OnPlayerDrop(void) : "Fired whenever the player drops the core."
	
	input EnableMotion(void) : "Enable physics motion/collision response."
	input DisableMotion(void) : "Disable physics motion/collision response."

	input EnableFlashlight(void) : "Enable the eye flashlight."
	input DisableFlashlight(void) : "Disable the eye flashlight."
	
	input ForcePickup(void) : "Force the player to pickpup the sphere."
	input EnablePickup(void) : "Allow player pickup."
	input DisablePickup(void) : "Disable player pickup."
	
	input PlayAttach(void) : "Play the attach animation, used for syncing with the socket animation."
	input PlayDetach(void) : "Play the attach animation, used for syncing with the socket animation."
	input PlayLock(void) : "Play the lock animation, used for syncing with the socket animation."
	
	input SetIdleSequence(string) : "Set a sequence to use as an idle."
	input ClearIdleSequence(void) : "Return to the default idle animation."

	input Explode(void) : "Explode the sphere."
]

@PointClass base(BasePropPhysics,Parentname) studio("models/npcs/monsters/monster_a.mdl") = prop_monster_box
[
	StartAsBox(boolean) : "Start As Box" : 0 : "Start as an Box."
	BoxSwitchSpeed(float) : "Box Switch Speed" : 400 : "Speed to force switch to a box."
	AllowSilentDissolve(boolean) : "Allow SilentDissolve input" : 0 : "Allow the SilentDissolve input to dissolve this monster."
	
	input BecomeBox(string) : "Force the monster to stay as a box."
	input BecomeMonster(void) : "Allow the monster to come out when set down."
	input BecomeShortcircuit(void) : "Short circuit this box and don't allow him to move anymore."
	
	input  Dissolve(void) : "Dissolves the monster."
	output OnFizzled(void) : "Fired when the monster gets fizzled."
	input  SilentDissolve(void) : "Kills the monster box and fires its OnFizzled output."
]

@PointClass base(Targetname, Parentname, Angles) studio("models/props/sign_frame01/sign_frame01.mdl") line(255 255 0, targetname, IndicatorLights) = prop_indicator_panel
[
	TimerDuration(float) : "Timer Duration" : 0 : "Amount of time the counter will count down"
	Enabled(boolean) : "Start visible?" : 0 : "Whether the timer should be initially visible."
	IsTimer(boolean) : "Is a timer" : 0 : "Whether we're a countdown timer or not."
	IsChecked(boolean) : "Is checked" : 0 : "If this is a binary indicator, whether this is checked or not."

	IndicatorLights(target_destination) : "Indicator Lights" : "" : "If supplied, assumes this is a group of indicators lights to toggle when the indicator is toggled."

	input Check(void) : "Sets the indicator state to be 'checked'."
	input Uncheck(void) : "Sets the indicator state to be 'unchecked'."

	input Start(void) : "Start counting down."
	input Stop(void) : "Stop the counter at its current value."
	input Reset(void) : "Reset the timer back to its default value."
]

@PointClass base(Targetname, Parentname, Angles) studio("models/props/sign_frame01/sign_frame01.mdl") = prop_tic_tac_toe_panel
[
	output OnPlayer1Pinged(void) : "Fired if pinged by Player 1."
	output OnPlayer2Pinged(void) : "Fired if pinged by Player 2."
]

@SolidClass base(Trigger) = trigger_playerteam : "Triggers different outputs for different players touching the trigger."
[
	target_team(choices) : "Target Team" : 0 : "Which team (or all) to allow to touch this trigger." =
	[
		0 : "Both"
		3 : "Blue"
		2 : "Orange"
	]	

	trigger_once(boolean) : "Trigger Once" : "No" : "Only trigger once, then remove the trigger."

	output OnStartTouchOrangePlayer(void) : "Orange player has started touching the trigger."
	output OnStartTouchBluePlayer(void) : "Blue player has started touching the trigger."
	output OnEndTouchOrangePlayer(void) : "Orange player has stopped touching the trigger."
	output OnEndTouchBluePlayer(void) : "Blue player has stopped touching the trigger."
]

@SolidClass base(Targetname) = trigger_ping_detector : "Detects whether a player has pinged in its region."
[
	output OnOrangePlayerPinged(void) : "Fired when the orange player has pinged inside the trigger."
	output OnBluePlayerPinged(void) : "Fired when the blue player has pinged inside the trigger."
]

@PointClass base(Targetname) iconsprite("editor/info_landmark") = info_landmark_entry : "Entry landmark"
[
]

@PointClass base(Targetname) iconsprite("editor/info_landmark") = info_landmark_exit : "Exit landmark"
[
]

@PointClass base(Targetname) iconsprite("editor/game_end.vmt") = point_changelevel : "Level Change Entity"
[
	input ChangeLevel(string) : "Changes the level to the map name supplied as a parameter."
	output OnChangeLevel(void) : "Fired when the level is about to change."
]

@PointClass base(Targetname, Parentname, Angles, BaseProjector, Reflection, Shadow) studio("models/props/tractor_beam_emitter.mdl") = prop_tractor_beam : "Emitter for a tractor beam."
[
	linearForce(float) : "Linear Force" : 250 : "Linear force to apply to objects in the beam."
	noemitterparticles(boolean) : "Disable Emitter Particles" : 0 : "Disable the whirly particles on the emitter."
	input SetLinearForce(float) : "Set the linear force applied to objects in the beam."
	use128model(boolean) : "Use 128 model" : 0 : "Use the tbeam projector model that fits within a 128 unit square."
	// input Enable(void) : "Turn the beam on."
	// input Disable(void) : "Turn the beam off."
]

@PointClass base(Targetname, Parentname, Angles) studio("models/editor/cone_helper.mdl") = info_paint_sprayer : "An entity that sprays paint."
[
	//Paint sprayer
	maxblobcount(integer) : "Max number of blobs" : 250 : "Max number of blobs that sprayer can spawn in the world (1-250)."
	light_position_name(string) : "Light Position Name" : : "Name of the entity we want to use as blobs light position."
	start_active(boolean) : "Start Active?" : 0
	silent(boolean) : "Silent?" : "0" : "If this flag is true, blobs will only paint (no render, effect, or sound)"
	DrawOnly(boolean) : "DrawOnly?" : "0" : "If this flag is true, blobs will only render (no paint, effect, or sound)"
	PaintType(choices) : "Paint Type" : 0 :
	"The type of paint sprayed." = 
	[
		0 : "Bounce"
		1 : "Stick"
		2 : "Speed"
		3 : "Portal"
		4 : "Erase"
	]
	
	RenderMode(choices) : "Render Mode" : 0 :
	"The mode to render blobs." = 
	[
		0 : "Blobulator"
		1 : "Fast Sphere"
	]
	
	AmbientSound(choices) : "Ambient Sound" : 0 :
	"The sound to play when paint is flowing." =
	[
		0 : "None (silent)"
		1 : "Drip"
		2 : "Medium Flow"
		3 : "Heavy Flow"
	]
	
	blobs_per_second(float) : "Blobs per second" : "1" : "The number of paint blobs sprayed per second."
	min_speed(float) : "Min blob speed" : "100" : "The minimum speed of the sprayed blobs."
	max_speed(float) : "Max blob speed" : "100" : "The maximum speed of the sprayed blobs."
	blob_spread_radius(float) : "Blob spread radius" : "0" : "The starting radius of the spread of the blobs."
	blob_spread_angle(float) : "Blob spread angle" : "0" : "The spread of the blobs along its direction vector (in degrees)."
	blob_streak_percentage(float) : "Blob streak percentage" : "0" : "The percentage of blobs that will streak (0 - 100)."
	min_streak_time(float) : "Blob min streak time" : "0.2" : "The minimum time that the blobs will streak for."
	max_streak_time(float) : "Blob max streak time" : "0.5" : "The maximum time that the blobs will streak for."
	min_streak_speed_dampen(float) : "Blob min streak speed dampen" : "500" : "The minimum speed dampening while streaking."
	max_streak_speed_dampen(float) : "Blob max streak speed dampen" : "1000" : "The maximum speed dampening while streaking."

	input Start(void) : "Tell the paint sprayer to start spraying."
	input Stop(void) : "Tell the paint sprayer to stop spraying."
	input ChangePaintType(integer) : "Change the type of paint being sprayed."
]

@PointClass base(Targetname,Angles) studio("models/props/futbol.mdl") = prop_paint_bomb : "Paint bomb that explodes on impact."
[
	//Paint bomb
	PaintType(choices) : "Paint Type" : 4 :
	"The type of paint to explode." = 
	[
		0 : "Bounce"
		1 : "Stick"
		2 : "Speed"
		3 : "Portal"
		4 : "Erase"
	]
	
	BombType(choices) : "Bomb Type" : 0 :
	"The type of explosion." = 
	[
		0 : "Dry Bomb"
		1 : "Wet Bomb"
	]

	allowfunnel(boolean) : "Allow Portal Funneling" : 1 : "Whether or not this object should auto-funnel into a portal."
	AllowSilentDissolve(boolean) : "Allow SilentDissolve input" : 0 : "Allow the SilentDissolve input to dissolve this bomb."
	
	playspawnsound(boolean) : "Play Spawn Sound" : 1 : "Whether or not this bomb should play a sound on spawn."

	input  Dissolve(void) : "Dissolves the paint bomb."
	input  SilentDissolve(void) : "Kills the paint bomb and fires its OnFizzled output."
	input  EnablePortalFunnel(void) : "Enable portal funneling behavior."
	input  DisablePortalFunnel(void) : "Disable portal funneling behavior."
	
	output OnFizzled(void) : "Fired when a paint bomb is fizzled."
	output OnExploded(void) : "Fired when a paint bomb explodes."
]


@PointClass base(Item) studio("models/items/healthkit.mdl") = item_paint_power_pickup : "Paint Ammo"
[
	// Paint power pickup
	PaintType(choices) : "Paint Type" : 0 :
	"The paint power of the pickup." =
	[
		0 : "Bounce"
		1 : "Stick"
		2 : "Speed"
		3 : "Portal"
	]
]

@SolidClass base(Trigger, Targetname) = trigger_paint_cleanser : 
	"A trigger volume that fizzles paint powers from the gun when the player touches it."
[
]

@PointClass base(Weapon) studio("models/weapons/w_portalgun.mdl") = weapon_paintgun : "Paintgun" []

@PointClass base(Targetname) = point_survey : "Displays a survey to the player"
[
	surveyname(string) : "Survey Name" : : "The name of the survey keyvalues file."
	input ShowSurvey(string) : "Displays the survey."
	output OnSurveyComplete(void) : "Fired when the player finishes a survey."
]

@PointClass base(Targetname, Angles) studio("models/effects/cappoint_hologram.mdl") = portal_race_checkpoint : "Checkpoint for race maps."
[
	ResetTime(float) : "Reset Time" : "5.0" : "The time it takes for the checkpoint to reset after activation"
	
	output OnCheckpointActivated(void) : "Fired when the checkpoint is activated by the player."
	output OnCheckpointReset(void) : "Fired when the checkpoint is reset after being activated by the player."
	
	input Activate(void) : "Activates the checkpoint."
	input CancelActivate(void) : "Cancels the checkpoint's activated state."
	input Lock(void) : "Locks the checkpoint from being activated."
	input Unlock(void) : "The checkpoint can be activated."
]

@PointClass base(Targetname, Parentname, Angles) studio("models/editor/axis_helper_thick.mdl") = vgui_level_placard_display :
"Pre-level display placard entity."
[
]

@PointClass base(Targetname, Parentname, Angles) studio("models/editor/axis_helper_thick.mdl") = vgui_mp_lobby_display :
"MP lobby display for day selection."
[
]

@PointClass base(BasePropPhysics) studio( "models/props/futbol.mdl" ) = prop_exploding_futbol : "Magic exploding futbol which the player uses to power futbol sockets."
[
	SpawnerName(string)	: "Spawner Name" : "" : "Name of prop_exploding_futbol_spawner for this futbol to respawn in once it has exploded."
	ShouldRespawn(boolean) : "Should Respawn" : "0" : "Should the futbol respawn at its spawner after exploding. Note: Spawner needs to be set for this to work."
	ExplodeOnTouch(boolean) : "Explode on touch" : "1" : "If the futbol should explode when it touches something."
	
	input Explode(void) : "Explodes the futbol."
]

@PointClass base(Targetname) studio( "models/props/futbol_dispenser.mdl" ) = prop_exploding_futbol_spawner : "Spawns magic exploding futbols. Will re-create a futbol when it's created futbol explodes."
[
	StartWithFutbol(boolean) : "Start with Futbol" : "1" : "Set true if this spawner starts with a futbol in it. Set to false if this spawner's futbol will be maunally placed in the map."
	IsTimed(boolean) : "Is Futbol Timed?" : "0" : "If the futbol should explode after a set amount of time."
	Timer(float) : "Explode Timer" : "0" : "The time after which the futbol explodes if it is timed."
	TimerIndicatorName(target_destination) : "Timer Indicator Panel" : "" : "The name of the timer panel associated with the futbol, if any."
	
	// Inputs
	input ForceSpawn(void)	: "Spawns a new futbol. Usually isn't nessicary, because futbols respawn automatically if broken."
	
	// Outputs
	output OnFutbolSpawned(void) : "Created a new futbol."
	output OnFutbolGrabbed(void) : "Player has taken the futbol out of this spawner."
]

@PointClass base(Targetname) studio( "models/props/futbol_socket.mdl" ) = prop_exploding_futbol_socket : "Catches futbols and fires an output."
[
	// Outputs
	output OnFutbolReleased(void) : "Player has taken the futbol out of this socket."
	output OnFutbolCaught(void)	: "This socket has captured a futbol."
]

@PointClass base(Targetname, Angles) sphere(radius) sphere(inner_radius) = point_push: "Point Push"
[
	spawnflags(Flags) = 
	[
		1 : "Test LOS before pushing" : 0
		2 : "Use angles for push direction" : 0
		4 : "No falloff (constant push at any distance)" : 0
		8 : "Push players" : 1
		16 : "Push physics" : 1
	]
	
	enabled(boolean) : "Start Enabled"	: 1
	
	magnitude(float) : "Magnitude" : 100 : "How strongly to push away from the center."
	radius(float) : "Radius" : 128 : "Radius to affect items in."
	inner_radius(float) : "Inner radius" : "0" : "If not zero, the LOS is calculated from a point intersecting this sphere."
	influence_cone(float) : "Cone of Influence" : "0" : "If greater than zero, the cone (in degrees) within which the object must lie for it to be affected."

	input Enable(void) : "Enable the push."
	input Disable(void): "Disable the push."
]

@PointClass base(prop_physics) sphere(fademindist) sphere(fademaxdist) studioprop() = prop_physics_paintable :
	"A dynamic prop that can be painted."
[
	PaintPower(choices) : "Paint Power" : 4 :
	"The paint power of the pickup." =
	[
		0 : "Bounce"
		1 : "Stick"
		2 : "Speed"
		3 : "Portal"
		4 : "None"
	]
]

@PointClass base(Targetname) iconsprite("editor/logic_coop_manager.vmt") = logic_coop_manager :
	"Manages two sets of values and can fire outputs based on the state of those values. " +
	"Useful in coop where you can have players independently setting states on buttons, switches, etc."
[
	// keys
	DefaultPlayerStateA(choices) : "Default State A" : 0 :
	"The default state of A" = 
	[
		0 : "FALSE"
		1 : "TRUE"
	]
	DefaultPlayerStateB(choices) : "Default State B" : 0 :
	"The default state of B" = 
	[
		0 : "FALSE"
		1 : "TRUE"
	]
	
	// Inputs
	input SetStateATrue(void) : "Set State A to TRUE"
	input SetStateAFalse(void) : "Set State A to FALSE"
	input ToggleStateA(void) : "Toggle State A"
	input SetStateBTrue(void) : "Set State B to TRUE"
	input SetStateBFalse(void) : "Set State B to FALSE"
	input ToggleStateB(void) : "Toggle State B"

	// Outputs
	output OnChangeToAllTrue(void) : "Fires when ALL of the values change to TRUE for the first time"
	output OnChangeToAnyTrue(void) : "Fires when ANY of the values change to tTRUE for the first time"
	output OnChangeToAllFalse(void) : "Fires when ALL of the values change to FALSE for the first time"
	output OnChangeToAnyFalse(void) : "Fires when ANY of the values change to FALSE for the first time"
]


@PointClass base(Targetname, Parentname, Angles) studio("models/props/portal_door_combined.mdl") = prop_testchamber_door :
"Test chamber door entity."
[
	lightingorigin(target_destination) : "Lighting Origin" : "" : "Select an info_lighting to specify a location to sample lighting from for all gibs spawned by this shooter, instead of their own origins."

	AreaPortalWindow(target_destination) : "Area Portal Window Name" : "" : "The name of an area portal window that is controlled by the door."
	UseAreaPortalFade(boolean) : "Fade Area Portal?" : 0 : "If the area portal should use the specified fade distances to fade out."
	AreaPortalFadeStart(float) : "Fade Start Distance" : 0 : "The distance at which the area portal starts fading out."
	AreaPortalFadeEnd(float) : "Fade End Distance" : 0 : "The distance at which the area portal turns completely opaque."

	input Open(void) : "Open the door and cause the portal to activate."
	input Close(void) : "Close the door and cause the portal to deactivate."
	input Lock(void) : "Locking a door will prevent the Open or Close inputs from doing anything."
	input Unlock(void) : "If locked, unocking a door will allow the Open or Close inputs to function."

	output OnOpen(void) : "Called when the door has started its open animation."
	output OnClose(void) : "Called when the door has started its close animation."
	output OnFullyOpen(void) : "Called when the door has finished its open animation."
	output OnFullyClosed(void) : "Called when the door has finished its close animation."
]

@PointClass base(BaseNPC, Parentname, RenderFields, Shadow) studio() = npc_wheatley_boss : "Wheatley NPC stub"
[
	model(studio) : "Model"
]


@PointClass base(Targetname) sphere(radius) = paint_sphere : "Paint brush entities inside the sphere"
[
	paint_type(choices) : "Paint Type" : 0 :
	"The type of paint." = 
	[
		0 : "Bounce"
		1 : "Stick"
		2 : "Speed"
		3 : "Portal"
		4 : "Erase"
	]
	
	radius(float) : "Radius" : "60.f" : "Radius of paint sphere"
	
	alpha_percent(float) : "Alpha Percent" : "1.0" : "Alpha percent to control the density of paint, the value must be between 0 to 1"
	
	input Paint(void) : "Apply paint with specified paint type inside the paint sphere"
]
