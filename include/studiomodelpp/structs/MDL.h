#pragma once

#include <array>
#include <cstddef>
#include <cstdint>
#include <string>
#include <vector>

#include <sourcepp/math/Angles.h>
#include <sourcepp/math/Matrix.h>
#include <sourcepp/math/Vector.h>

#include "Generic.h"

namespace studiomodelpp::MDL {

struct Bone {
	enum Flags : int32_t {
		FLAG_NONE = 0,
		// todo(flags): Bone
	};

	//int32_t nameIndex;
	std::string name;

	int32_t parent;
	int32_t boneController[6];
	sourcepp::Vec3f position;
	sourcepp::Quat rotationQuat;
	sourcepp::Vec3f rotationEuler;
	sourcepp::Vec3f positionScale;
	sourcepp::Vec3f rotationScale;
	sourcepp::Matrix<3,4> poseToBose;
	sourcepp::Quat alignment;
	Flags flags;
	int32_t procType;
	int32_t procIndex;
	int32_t physicsBone;

	//int32_t surfacePropNameIndex;
	std::string surfacePropName;

	int32_t contents;

	//int32_t _unused0[8];
};

struct BoneController {
	int32_t bone;
	int32_t type;
	float start;
	float end;
	int32_t rest;
	int32_t inputField;

	//int32_t _unused0[8];
};

struct HitboxSet {
	//int32_t nameIndex;
	std::string name;

	//int32_t hitboxCount;
	//int32_t hitboxIndex;
	std::vector<BBox> hitboxes;
};

/*
struct AnimDesc {
	enum Flags : int32_t {
		FLAG_NONE     = 0,
		FLAG_RAW_POS  = 1 << 0,
		FLAG_RAW_ROT  = 1 << 1,
		FLAG_ANIM_POS = 1 << 2,
		FLAG_ANIM_ROT = 1 << 3,
		FLAG_DELTA    = 1 << 4,
		FLAG_RAW_ROT2 = 1 << 5,
	};

	//int32_t basePointer;

	//int32_t nameIndex;
	std::string name;
	float fps;

	Flags flags;

	int32_t frameCount;

	//int32_t movementCount;
	//int32_t movementIndex;

	//int32_t _unused0[6];

	//int32_t animBlock;
	//int32_t animIndex;

	//int32_t ikRuleCount;
	//int32_t ikRuleIndex;

	//int32_t animBlockIKRuleIndex;

	//int32_t localHierarchyIndexCount;
	//int32_t localHierarchyIndex;

	//int32_t sectionIndex;
	//int32_t sectionFrames;

	//int16_t zeroFrameSpan;
	//int16_t zeroFrameCount;
	//int32_t zeroFrameIndex;
	//float zeroFrameStallTime;
};

struct SequenceDesc {
	enum Flags : int32_t {
		FLAG_NONE = 0,
		FLAG_LOOPING = 1 << 0,
	};

	//int32_t basePointer;

	//int32_t labelIndex;
	//int32_t activityLabelIndex;

	Flags flags;

	//int32_t activity;
	//int32_t activityWeight;

	//int32_t eventCount;
	//int32_t eventIndex;

	sourcepp::Vec3f boundingBoxMin;
	sourcepp::Vec3f boundingBoxMax;

	int32_t blendCount;

	int32_t animIndexIndex;

	int32_t movementIndex;

	int32_t groupSize[2];
	int32_t paramIndex[2];
	float paramStart[2];
	float paramEnd[2];
	int32_t paramParent;

	float fadeInTime;
	float fadeOutTime;

	int32_t localEntryNode;
	int32_t localExitNode;

	int32_t nodeFlags;

	float entryPhase;
	float exitPhase;

	float lastFrame;

	int32_t nextSequence;
	int32_t pose;

	int32_t ikRuleCount;

	//int32_t autoLayerCount;
	//int32_t autoLayerIndex;

	int32_t weightListIndex;

	int32_t poseKeyIndex;

	//int32_t ikLockCount;
	//int32_t ikLockIndex;

	//int32_t keyValueIndex;
	//int32_t keyValueSize;

	int32_t cyclePoseIndex;

	//int32_t _unused0[7];
};
*/

struct Material {
	enum Flags : int32_t {
		FLAG_NONE = 0,
		// todo(flags): Material (Texture in MDL)
	};

	//int32_t nameIndex;
	std::string name;

	Flags flags;

	//int32_t used; // No idea what this is
	//int32_t _unused0[13];
};

struct Mesh {
	int32_t material;

	//int32_t modelOffset;

	// These do not map to raw memory
	int32_t verticesCount;
	int32_t verticesOffset;

	//int32_t flexesCount;
	//int32_t flexesOffset;

	int32_t materialType;
	int32_t materialParam;

	int32_t meshID;

	sourcepp::Vec3f center;

	//int32_t modelVertexData;
	//int32_t numLODVertexes[MAX_LOD_COUNT];
	//int32_t _unused[8];
};

struct Model {
	//char name[64];
	std::string name;

	int32_t type;

	float boundingRadius;

	//int32_t meshesCount;
	//int32_t meshesOffset;
	std::vector<Mesh> meshes;

	// These do not map to raw memory
	int32_t verticesCount;
	int32_t verticesOffset;
	//int32_t tangentsOffset;

	//int32_t attachmentsCount;
	//int32_t attachmentsOffset;

	//int32_t eyeballsCount;
	//int32_t eyeballsOffset;

	//int32_t _unused0[10];
};

struct BodyPart {
	//int32_t nameOffset;
	std::string name;

	//int32_t modelsCount;
	int32_t base; // No idea what this is, might as well expose it
	//int32_t modelsOffset;
	std::vector<Model> models;
};

struct MDL {
	[[nodiscard]] bool open(const std::byte* data, std::size_t size);

	enum Flags : int32_t {
		FLAG_NONE                           = 0,
		FLAG_AUTOGENERATED_HITBOX           = 1 <<  0,
		FLAG_FORCE_OPAQUE                   = 1 <<  2,
		FLAG_TRANSLUCENT_TWO_PASS           = 1 <<  3,
		FLAG_STATIC_PROP                    = 1 <<  4,
		FLAG_HAS_SHADOW_LOD                 = 1 <<  6,
		FLAG_USE_SHADOW_LOD_MATERIALS       = 1 <<  8,
		FLAG_OBSOLETE                       = 1 <<  9,
		FLAG_NO_FORCED_FADE                 = 1 << 11,
		FLAG_FORCE_PHONEME_CROSSFADE        = 1 << 12,
		FLAG_CONSTANT_DIRECTIONAL_LIGHT_DOT = 1 << 13,
		FLAG_FLEXES_CONVERTED               = 1 << 14,
		FLAG_BUILT_IN_PREVIEW_MODE          = 1 << 15,
		FLAG_DO_NOT_CAST_SHADOWS            = 1 << 17,
		FLAG_CAST_TEXTURE_SHADOWS           = 1 << 18,
		FLAG_SUBDIVISION_SURFACE            = 1 << 19,
		FLAG_VERT_ANIM_FIXED_POINT_SCALE    = 1 << 21,
		FLAG_EXTRA_VERTEX_DATA              = 1 << 26,
	};

	//int32_t id;
	int32_t version;
	int32_t checksum;

	//char name[64];
	std::string name;
	//int32_t dataLength;

	sourcepp::Vec3f eyePosition;
	sourcepp::Vec3f illuminationPosition;
	sourcepp::Vec3f hullMin;
	sourcepp::Vec3f hullMax;
	sourcepp::Vec3f viewBBoxMin;
	sourcepp::Vec3f viewBBoxMax;

	Flags flags;

	//int32_t boneCount;
	//int32_t boneOffset;
	std::vector<Bone> bones;

	//int32_t boneControllerCount;
	//int32_t boneControllerOffset;
	std::vector<BoneController> boneControllers;

	//int32_t hitboxCount;
	//int32_t hitboxOffset;
	std::vector<HitboxSet> hitboxSets;

	//int32_t localAnimationCount;
	//int32_t localAnimationOffset;

	//int32_t localSequenceCount;
	//int32_t localSequenceOffset;

	int32_t activityListVersion;
	int32_t eventsIndexed;

	//int32_t materialCount;
	//int32_t materialOffset;
	std::vector<Material> materials;

	//int32_t materialDirCount;
	//int32_t materialDirOffset;
	std::vector<std::string> materialDirectories;

	//int32_t skinReferenceCount;
	//int32_t skinReferenceFamilyCount;
	//int32_t skinReferenceIndex;
	// Each vector is an individual skin, which holds indices into the materials vector
	std::vector<std::vector<int16_t>> skins;

	//int32_t bodyPartCount;
	//int32_t bodyPartOffset;
	std::vector<BodyPart> bodyParts;

	//int32_t attachmentCount;
	//int32_t attachmentOffset;

	//int32_t localNodeCount;
	//int32_t localNodeIndex;
	//int32_t localNodeNameIndex;

	//int32_t flexDescCount;
	//int32_t flexDescIndex;

	//int32_t flexControllerCount;
	//int32_t flexControllerIndex;

	//int32_t flexRulesCount;
	//int32_t flexRulesIndex;

	//int32_t ikChainCount;
	//int32_t ikChainIndex;

	//int32_t mouthsCount;
	//int32_t mouthsIndex;

	//int32_t localPoseParamCount;
	//int32_t localPoseParamIndex;

	//int32_t surfacePropertyIndex;

	//int32_t keyValueIndex;
	//int32_t keyValueCount;

	//int32_t ikLockCount;
	//int32_t ikLockIndex;

	//float mass;
	//int32_t contentsFlags;

	//int32_t includeModelCount;
	//int32_t includeModelIndex;

	//int32_t virtualModel;

	//int32_t animationBlocksNameIndex;

	//int32_t animationBlocksCount;
	//int32_t animationBlocksIndex;

	//int32_t animationBlockModel;

	//int32_t boneTableNameIndex;

	//int32_t vertexBase;
	//int32_t offsetBase;

	//std::byte directionalDotProduct;

	//uint8_t rootLOD;
	//uint8_t numAllowedRootLODs;

	//std::byte _unused0;
	//int32_t _unused1;

	//int32_t flexControllerUICount;
	//int32_t flexControllerUIIndex;

	//float vertAnimFixedPointScale;
	//int32_t _unused2;

	// todo: header 2
	//int32_t header2Offset;

	//int32_t _unused3;
};

} // namespace studiomodelpp::MDL
